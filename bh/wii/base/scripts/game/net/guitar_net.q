online_lockout_gamemode = Default
num_players_info = [
	{
		Name = qs(0x576d469b)
		checksum = num_1
		num = 1
	}
	{
		Name = qs(0xe39e174e)
		checksum = num_2
		num = 2
	}
	{
		Name = qs(0x0ccca1af)
		checksum = num_3
		num = 3
	}
	{
		Name = qs(0xede2abcb)
		checksum = num_4
		num = 4
	}
	{
		Name = qs(0x02b01d2a)
		checksum = num_4
		num = 5
	}
	{
		Name = qs(0xe836c048)
		checksum = num_6
		num = 6
	}
	{
		Name = qs(0x076476a9)
		checksum = num_4
		num = 7
	}
	{
		Name = qs(0xf11bd2c1)
		checksum = num_8
		num = 8
	}
]
num_private_slots = [
	{
		Name = qs(0xe64a7ccd)
		checksum = num_0
		num = 0
	}
	{
		Name = qs(0x0918ca2c)
		checksum = num_1
		num = 1
	}
]
ranked_info = [
	{
		Name = qs(0x3489402d)
		checksum = Player
		num = 1
	}
	{
		Name = qs(0xd6e06d82)
		checksum = Ranked
		num = 0
	}
]
join_in_progress_info = [
	{
		Name = qs(0xefa31a4a)
		num = 0
		checksum = no
	}
	{
		Name = qs(0xe5fd67fa)
		num = 1
		checksum = yes
	}
]
net_game_type_info = [
	{
		Name = qs(0x911a725e)
		description = qs(0xb96bc46d)
		checksum = compmega
		func = is_gamemode_visible
		search_chk = mode_extra_2
	}
	{
		Name = qs(0xdf462cd2)
		description = qs(0xb96bc46d)
		checksum = compmega_team
		func = is_gamemode_visible
		search_chk = mode_extra_3
	}
	{
		Name = qs(0x95e93b27)
		description = qs(0xb96bc46d)
		checksum = fest_mode
		func = is_gamemode_visible
		search_chk = mode_extra_1
	}
	{
		Name = qs(0x95e93b27)
		description = qs(0xb96bc46d)
		checksum = fest_mode_team
		func = is_gamemode_visible
		search_chk = p4_pro_faceoff
	}
	{
		Name = qs(0x9d053fe6)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
		search_chk = p2_pro_faceoff
	}
	{
		Name = qs(0x4a7dbf01)
		description = qs(0xb96bc46d)
		checksum = p4_pro_faceoff
		func = is_gamemode_visible
		search_chk = p4_pro_faceoff
	}
	{
		Name = qs(0x2a7276c2)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
		search_chk = p2_pro_faceoff_bass
	}
	{
		Name = qs(0x7c4bcefd)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
		search_chk = p2_pro_faceoff_drums
	}
	{
		Name = qs(0x28840c51)
		description = qs(0x2d3d2fa9)
		checksum = p2_quickplay
		func = is_gamemode_visible
		search_chk = p2_coop
	}
	{
		Name = qs(0x98fa7ed6)
		description = qs(0x2d3d2fa9)
		checksum = p4_quickplay
		func = is_gamemode_visible
		search_chk = p4_quickplay
	}
	{
		Name = qs(0xb39401d6)
		description = qs(0x323709dd)
		checksum = p8_pro_faceoff
		func = is_gamemode_visible
		search_chk = p8_pro_faceoff
	}
	{
		Name = qs(0xdf90fff4)
		description = qs(0x655c34df)
		checksum = career
		func = is_gamemode_visible
		search_chk = career
	}
]
beta_net_game_type_info = [
	{
		Name = qs(0x899a96c8)
		description = qs(0xb96bc46d)
		checksum = p2_pro_faceoff
		func = is_gamemode_visible
	}
	{
		Name = qs(0x425b9950)
		description = qs(0xb96bc46d)
		checksum = p4_pro_faceoff
		func = is_gamemode_visible
	}
]
net_guitar_part_info = [
	{
		Name = qs(0x0cc7d9b2)
		checksum = guitar
	}
	{
		Name = qs(0x7d4f9214)
		checksum = bass
	}
]
controller_lookup_table = {
	controller = 'Vocal'
	guitar = 'Guitar'
	drum = 'Drum'
	bass = 'Bass'
	vocals = 'Vocal'
}
net_drop_packet_percentage = 0
NO_NET_MODE = 0
LAN_MODE = 1
INTERNET_MODE = 2
net_permision_to_select_song = 0
net_pause = 0
net_num_players_data_ack = 0
net_num_players_data_needed = 0
net_dropped_players_flag = 0
recovered_dropped_players = 0
message_of_the_day = qs(0x00000000)
online_song_choice_id = 0
online_signin_autoload_required = 0
net_autolaunch_role = None
net_popup_active = 0
matchmaking_countdown_complete_callback = move_to_net_setlist
net_autolaunch_level = americanwoman
net_autolaunch_song = load_z_frathouse
net_song_breakdown_countdown_time = 10
xenon_invite_confirm_title = qs(0xf3c9603f)
xenon_invite_confirm_dialog = qs(0xb202cc8b)
xenon_invite_confirm_yes = qs(0xb73cb78f)
xenon_invite_confirm_no = qs(0xf7723015)
xenon_invite_disallowed_title = qs(0xf3c9603f)
xenon_invite_disallowed_dialog = qs(0xc9d447ca)
xenon_invite_disallowed_ok = qs(0x0e41fe46)
ps3_non_primary_controller_id = qs(0xee4339cd)
ps3_invite_postion = (255.0, 96.0)

script net_autolaunch_spawned 
	Change game_mode = ($autolaunch_gamemode)
	netoptions :pref_choose Name = game_modes checksum = ($game_mode)
	generic_event_choose event = <event> no_sound state = uistate_signin data = {device_num = 0 primary = 1 allow_back = 1 new_state = uistate_net_setup require_live = 1 net_auto_launch = 1}
	Block \{Type = online_menu_created}
	add_active_controllers
	begin
	printf \{qs(0xee7c4887)}
	if ScreenElementExists \{id = current_menu}
		if all_clients_are_ready
			Wait \{0.5
				Seconds}
			break
		endif
	endif
	Wait \{0.5
		Seconds}
	repeat
	printf \{qs(0xdabc8077)}
	Change \{online_to_setlist_count = 5}
	start_matchmaking device_num = ($primary_controller)
	Change \{matchmaking_countdown_complete_callback = autolaunch_goto_setlist}
endscript

script autolaunch_goto_setlist 
	ScriptAssert \{qs(0x4fcdb2ee)}
	ui_event_block \{event = menu_add
		state = uistate_songlist
		data = {
			base_name = 'songlist'
		}}
	if local_player_is_choosing_song
		Change current_level = ($net_autolaunch_level)
		gman_songtool_setcurrentsong \{song = $net_autolaunch_song}
		Wait \{2.0
			Seconds}
		if IsHost
			host_proceed_to_online_play
		endif
	endif
endscript

script al_refresh 
	ui_event \{event = menu_replace
		data = {
			state = uistate_net_debug_lobby
			mode = CLIENT
		}}
	al_get_server_list
endscript

script al_get_server_list 
	printf \{qs(0x6c672f1c)}
	al_get_preferences
	get_server_list \{callback = autolaunch_add_server
		callback_complete = autoloaunch_results_stop}
endscript

script get_server_list \{callback = empty_script
		callback_complete = empty_script}
	Change \{xboxlive_num_results = 0}
	NetSessionFunc \{Obj = match
		func = stop_server_list}
	NetSessionFunc \{Obj = match
		func = free_server_list}
	net_dummy_get_needed_search_params
	NetSessionFunc Obj = match func = set_search_params params = <...>
	NetSessionFunc \{Obj = match
		func = set_server_list_mode
		params = {
			optimatch
		}}
	NetSessionFunc {
		Obj = match
		func = start_server_list
		params = {
			callback = <callback>
			callback_complete = <callback_complete>
		}
	}
endscript

script al_get_preferences 
	return {
		difficulty = ($net_autolaunch_parms.difficulty)
		gamemode = ($net_autolaunch_parms.gamemode)
		num_songs = ($net_autolaunch_parms.num_songs)
	}
endscript

script autolaunch_add_server 
	printf \{qs(0x1cb462bf)}
	Change xboxlive_num_results = (($xboxlive_num_results) + 1)
	add_generic_menu_text_item text = <server_name> pad_choose_script = net_al_choose_server pad_choose_params = {server_name = <server_name> server_id = <server_id>}
endscript

script autolaunch_results_stop 
	if GotParam \{xboxlive_num_results}
		Change xboxlive_num_results = <xboxlive_num_results>
	endif
	printf qs(0xef0ddf26) d = ($xboxlive_num_results)
endscript

script net_al_choose_server 
	printf qs(0x4c82f9cb) s = <server_name> d = <server_id>
	NetSessionFunc Obj = match func = choose_server params = {id = <server_id>}
	ui_event event = menu_change data = {state = uistate_net_debug_lobby_join server_name = <server_name>}
endscript

script setup_and_post_game 
	NetSessionFunc \{Obj = match
		func = stop_server_list}
	NetSessionFunc \{Obj = match
		func = free_server_list}
	<rand> = 0
	GetRandomValue \{Name = rand
		integer
		a = 0
		b = 1}
	if ((<rand> = 0) || ($game_mode = p2_coop) || (<num_songs> = 1))
		Change \{tie_breaker = HOST}
	else
		Change \{tie_breaker = CLIENT}
	endif
	if IsHost
		ResetHubStates
	endif
	post_network_game controller = <device_num>
endscript

script quit_network_game 
	printf \{qs(0xffb8716a)}
	KillSpawnedScript \{Name = loading_screen_crowd_swell}
	KillSpawnedScript \{Name = crowd_loading_whistle}
	KillSpawnedScript \{Name = net_career_gig_info_continue_for_clients}
	LeaveServer
	RemoveTimeSyncTask
	removematchmakinghandofftask
	clear_wait_for_net_match_available_items
	songlistmatch \{func = quit_network_game}
	if NOT GotParam \{0x026d6679}
		sdcardmanagerfunc \{func = net_hold_ejects
			OFF}
	endif
	call_it = 1
	if GotParam \{no_unpost}
		if (<no_unpost> = 1)
			call_it = 0
		endif
	endif
	if (<call_it> = 1)
		NetSessionFunc \{Obj = session
			func = unpost_game}
	else
		NetSessionFunc \{Obj = session
			func = stop_singleplayer_session}
	endif
	netoptions :pref_choose \{Name = private_slots
		value = 0}
	netoptions :pref_choose \{Name = Ranked
		checksum = Player}
	gamemode_gettype
	if checksumequals a = ($competitive_rules) b = p8_pro_faceoff
		gamemode_updatenumplayers \{num_players = 8}
		gamemode_setteamsize \{team_size = 4}
	elseif checksumequals a = ($game_mode) b = fest_mode
		gamemode_updatenumplayers \{num_players = 8}
	elseif checksumequals a = ($game_mode) b = fest_mode_team
		gamemode_updatenumplayers \{num_players = 8}
		gamemode_setteamsize \{team_size = 2}
	elseif (<Type> = competitive)
		gamemode_updatenumplayers \{num_players = 8}
		if checksumequals a = ($game_mode) b = compmega_team
			gamemode_setteamsize \{team_size = 2}
		endif
	elseif (<Type> = trivia)
		gamemode_updatenumplayers \{num_players = 4}
	endif
endscript

script is_valid_net_game_setup 
	printf \{qs(0xb074009f)}
	<is_valid> = 0
	<all_the_same_part> = 1
	<num_guitars> = 0
	<num_vocals> = 0
	<num_drums> = 0
	getnumplayersingame
	if (<num_players> > 0)
		getfirstplayer
		getplayerinfo <Player> part out = first_part
		begin
		getplayerinfo <Player> part
		if (<all_the_same_part> = 1)
			if NOT (<part> = <first_part>)
				<all_the_same_part> = 0
			endif
		endif
		switch (<part>)
			case bass
			case guitar
			<num_guitars> = (<num_guitars> + 1)
			case drum
			<num_drums> = (<num_drums> + 1)
			case vocals
			<num_vocals> = (<num_vocals> + 1)
		endswitch
		getnextplayer Player = <Player>
		repeat <num_players>
	endif
	switch ($game_mode)
		case fest_mode
		case compmega
		case compmega_team
		case fest_mode_team
		if ($competitive_rules = team_faceoff)
			<is_valid> = 1
		elseif ($competitive_rules = p8_pro_faceoff)
			if (<num_players> > 0)
				if (<num_guitars> <= 2 && <num_drums> <= 1 && <num_vocals> <= 1)
					<is_valid> = 1
				else
					SendStructure \{callback = band_lobby_flash_ticker_msg
						data_to_send = {
							msg_checksum = incorrect_instrument
							time = 5
						}}
					band_lobby_flash_ticker_msg \{msg_checksum = incorrect_instrument
						time = 5}
				endif
			endif
		else
			if (<all_the_same_part> = 1 && <num_players> > 0)
				<is_valid> = 1
			else
				SendStructure \{callback = band_lobby_flash_ticker_msg
					data_to_send = {
						msg_checksum = incorrect_instrument
						time = 5
					}}
				band_lobby_flash_ticker_msg \{msg_checksum = incorrect_instrument
					time = 5}
			endif
		endif
		default
		<is_valid> = 0
	endswitch
	if (<is_valid> = 1)
		return \{true}
	else
		return \{FALSE}
	endif
endscript

script net_clear_player_info \{on_screen = 1}
	player_index = (<Player> - 1)
	RequireParams \{[
			Player
		]}
	printf qs(0x7500e57a) d = <Player>
	setplayerinfo <Player> is_local_client = 1
	setplayerinfo <Player> net_id_first = 0
	setplayerinfo <Player> net_id_second = 0
	setplayerinfo <Player> net_obj_id = -1
	setplayerinfo <Player> Band = 1
	setplayerinfo <Player> party_id = -1
	setplayerinfo <Player> is_onscreen = <on_screen>
	setplayerinfo <Player> in_game = 0
	formatText checksumName = gamertag 'gamertag_%d' d = (<player_index>)
	Change GlobalName = <gamertag> NewValue = qs(0x00000000)
	controller = (<player_index>)
	if (<controller> > 3)
		controller = 3
	endif
	setplayerinfo <Player> controller = <controller>
endscript

script net_clear_all_remote_player_info 
	Player = 1
	begin
	if playerinfoequals <Player> is_local_client = 0
		net_clear_player_info Player = <Player>
	else
		setplayerinfo <Player> Band = 1
	endif
	<Player> = (<Player> + 1)
	repeat 8
endscript

script shut_down_net_play 
	Change \{net_pause = 0}
	Change \{is_network_game = 0}
	SetNetworkMode
	NetSessionFunc \{Obj = match
		func = stop_server_list}
	NetSessionFunc \{Obj = match
		func = free_server_list}
	NetSessionFunc \{func = stats_uninit}
	if ($net_popup_active = 1)
		destroy_net_popup
	endif
	cleanup_sessionfuncs
	setup_sessionfuncs
	net_clear_all_remote_player_info
	setplayerinfo \{1
		highway_layout = default_highway}
	setplayerinfo \{2
		highway_layout = default_highway}
	destroy_player_drop_events
endscript

script select_quit_network_game 
	if ScreenElementExists \{id = yourock_text}
		DestroyScreenElement \{id = yourock_text}
	endif
	if ScreenElementExists \{id = yourock_text_2}
		DestroyScreenElement \{id = yourock_text_2}
	endif
	if ($net_popup_active = 0)
		gamemode_gettype
		if (<Type> = career)
		endif
		if GotParam \{from_fail_menu}
			generic_event_choose state = uistate_online_quit_warning data = {player_device = <device_num>}
		else
			if GotParam \{from_pause_menu}
				if ScreenElementExists \{id = generic_barrel_vmenu}
					LaunchEvent \{Type = unfocus
						target = generic_barrel_vmenu}
					generic_barrel_vmenu :se_setprops \{block_events}
				endif
			endif
			generic_event_choose no_sound state = uistate_online_quit_warning data = {player_device = <device_num>}
		endif
	endif
endscript

script quit_network_game_early 
	if NOT ($is_network_game)
		return
	endif
	begin
	if ($start_gem_scroller_running = 0)
		break
	elseif ($songtime_paused = 1)
		Change \{songtime_paused = 0}
	endif
	Wait \{1
		gameframe}
	repeat
	quit_network_game no_unpost = <no_unpost> 0x026d6679 = <0x026d6679>
	if GotParam \{signin_change}
		shut_down_net_play
	else
		if ($playing_song = 1)
			kill_gem_scroller
		endif
	endif
endscript

script generic_net_sync 
	cleargameover
	SyncAndLaunchNetGame
	broadcastevent \{Type = done_loading}
	begin
	if ($net_ready_to_start)
		if GotParam \{callback}
			if NOT GotParam \{callback_params}
				callback_params = {}
			endif
			<callback> <callback_params>
		endif
		break
	endif
	Wait \{1
		gameframe}
	repeat
	if IsHost
		resetclientsloading
	endif
endscript

script start_first_net_song 
	ui_event_get_top
	if NOT (<base_name> = 'gameplay')
		ui_event \{event = menu_replace
			data = {
				state = Uistate_gameplay
			}}
	endif
endscript

script continue_between_net_songs 
	printf \{qs(0xf792eb5e)}
	if ScreenElementExists \{id = song_breakdown_noncompetitive_id}
		Change \{song_breakdown_countdown_time = 5}
		ui_song_breakdown_setup_handler_scripts \{add_setlist_continue_handlers
			continue_to_next_song}
	elseif ScreenElementExists \{id = song_breakdown_competitive_id}
		Change \{song_breakdown_countdown_time = 5}
		ui_song_breakdown_competitive_setup_handler_scripts \{continue_setlist_transition
			add_setlist_continue_handlers}
	else
		ScriptAssert \{'unpausing song when we should start the timer'}
		gman_startgamemodegoal
		Change \{songtime_paused = 0}
	endif
endscript

script cancel_join_server 
	printf \{qs(0x8a62650c)}
	LeaveServer
	NetSessionFunc \{Obj = session
		func = unpost_game}
	NetSessionFunc \{Obj = match
		func = free_server_list}
endscript

script post_network_game 
	if (NetSessionFunc Obj = match func = get_gamertag params = {controller = <controller>})
		Change default_network_id = <Name>
		Change default_server_id = <Name>
	endif
	NetSessionFunc Obj = session func = post_game params = {controller_index = <controller>}
	SetServerMode
	StartServer
	SetJoinMode \{$JOIN_MODE_PLAY}
	JoinServer
endscript

script set_match_values 
	set_network_preferences \{dont_set}
	net_dummy_get_needed_search_params
	getfirstplayer
	getplayerinfo <Player> difficulty
	gamemode_gettype
	if checksumequals a = <Type> b = career
		difficulty = expert
	elseif checksumequals a = <Type> b = quickplay
		difficulty = expert
	endif
	return {
		difficulty = <difficulty>
		gamemode = <gamemode>
		num_songs = ($num_songs)
		scoring_mode = <scoring_mode>
	}
endscript

script set_network_preferences 
	printf \{qs(0x6cf9bcf7)}
	if NOT GotParam \{dont_set}
		gamemode_gettype
		if checksumequals a = <Type> b = quickplay
			netoptions :pref_choose \{Name = game_modes
				checksum = p4_quickplay}
			Change \{competitive_rules = faceoff}
		elseif checksumequals a = <Type> b = career
			netoptions :pref_choose \{Name = game_modes
				checksum = career}
			Change \{competitive_rules = faceoff}
		elseif checksumequals a = ($competitive_rules) b = p8_pro_faceoff
			netoptions :pref_choose Name = game_modes checksum = ($competitive_rules)
		else
			netoptions :pref_choose Name = game_modes checksum = ($game_mode)
		endif
		netoptions :pref_choose \{Name = Ranked
			checksum = Player}
		netoptions :pref_getstruct \{Name = game_modes}
		if checksumequals a = ($competitive_rules) b = p8_pro_faceoff
			Change \{game_mode = compmega_team}
		else
			Change game_mode = (<pref_struct>.checksum)
		endif
		gamemode_getnumplayers
		printf qs(0x8429c652) s = <num_players>
		netoptions :pref_choose Name = num_players value = <num_players>
	endif
	netoptions :pref_getstruct \{Name = game_modes}
	<leader_player> = ($g_leader_player_num)
	if (<leader_player> < 1)
		getfirstplayer \{local}
		<leader_player> = <Player>
	endif
	getplayerinfo <leader_player> difficulty
	getplayerinfo <leader_player> part
	search_checksum = (<pref_struct>.search_chk)
	if checksumequals a = ($game_mode) b = compmega
		if checksumequals a = <part> b = bass
			search_checksum = p2_pro_faceoff_bass
		endif
	endif
	if checksumequals a = ($game_mode) b = fest_mode
		if checksumequals a = <part> b = bass
			search_checksum = p2_pro_faceoff
		endif
	endif
	if checksumequals a = ($game_mode) b = fest_mode_team
		if checksumequals a = <part> b = bass
			search_checksum = p2_pro_faceoff_drums
		endif
	endif
	return {
		gamemode = <search_checksum>
		difficulty = <difficulty>
		num_songs = dont_care
	}
endscript

script set_netgame_globals 
	printf \{qs(0xc7b8dbb0)}
	printstruct <...>
	Change game_mode = <game_mode>
	Change current_level = <level>
	gamemode_getnumplayers
endscript

script cleanup_sessionfuncs 
	printf \{qs(0x7abbf921)}
	NetSessionFunc \{func = match_uninit}
	NetSessionFunc \{func = stats_uninit}
	NetSessionFunc \{func = 0xf53a6e5a}
endscript

script setup_sessionfuncs 
	printf \{qs(0x6deffbba)}
	if CheckForSignIn \{controller_index = 0
			dont_set_primary
			network_platform_only}
		NetSessionFunc \{func = match_init}
	endif
	NetSessionFunc \{func = stats_init}
	NetSessionFunc \{func = voice_init}
	NetSessionFunc \{func = motd_init}
	NetSessionFunc \{Obj = voice
		func = enable}
	if NetSessionFunc \{Obj = match
			func = get_gamertag}
		Change default_network_id = <Name>
		Change default_server_id = <Name>
	endif
endscript

script get_current_level_name 
	return level_name = ($LevelZones.($current_level).title) level = 1
endscript

script GetCurrentAreaStringAndChecksum 
	<area_string> = 'z_online_venue'
	<area_checksum> = dummy_value
endscript

script launch_game 
	gamemode_gettype
	if (<Type> = career)
		gman_songtool_getcurrentsong
		ui_event event = menu_change data = {state = uistate_play_song song_checksum = <current_song> song_index = ($net_career_song_index)}
	else
		generic_event_choose \{state = uistate_play_song}
	endif
endscript

script load_and_sync_timing \{start_delay = 3000}
	printf \{qs(0x73081805)}
	printf \{qs(0x5b6fd41c)
		i = $current_level}
	gamemode_gettype
	getplayerinfo \{1
		difficulty
		out = difficulty1}
	getplayerinfo \{2
		difficulty
		out = difficulty2}
	getplayerinfo \{1
		controller}
	if (<Type> != career)
		Change \{current_transition = fastintro}
		restart_gem_scroller difficulty = <difficulty1> difficulty2 = <difficulty2> starttime = 0 endtime = 999999999 device_num = <controller>
	else
		Transition_SelectTransition
		restart_gem_scroller difficulty = <difficulty1> difficulty2 = <difficulty2> starttime = 0 endtime = 999999999 device_num = <controller> loading_transition = 0
		($default_loading_screen.Destroy)
	endif
endscript

script launch_network_game 
	Change \{net_ready_to_start = 1}
endscript

script ranked_quit_fix_scores 
	song_index = 0
	begin
	SetArrayElement ArrayName = g_p2_scores globalarray index = <song_index> NewValue = 0
	<song_index> = (<song_index> + 1)
	repeat <num_songs>
endscript

script net_control_whammy_pitch_loop 
	Change \{pitch_dirty = 1}
	formatText checksumName = net_update_event 'net_button_check_p%d' d = <Player> AddToStringLookup = true
	begin
	GetSongTime
	start_time = <songtime>
	Block Type = <net_update_event>
	GetSongTime
	delta_time = (<songtime> - <start_time>)
	<time> = (<time> - (<delta_time> * 1000))
	KillSpawnedScript \{Name = net_whammy_pitch_shift}
	SpawnScriptNow net_whammy_pitch_shift params = {song = <song> array_entry = <array_entry> pattern = <pattern> Player = <Player> net_whammy_length = (<event_data>.net_whammy_length) time = <time>}
	repeat
	KillSpawnedScript \{Name = net_whammy_pitch_shift}
endscript
pitch_dirty = 1
prev_len = 0

script net_whammy_pitch_shift 
	if ($pitch_dirty = 1)
		Change \{pitch_dirty = 0}
		Change prev_len = <net_whammy_length>
		begin
		controlwhammypitchshift Player = <Player> net_whammy_length = <net_whammy_length> time = <time>
		Wait \{1
			gameframe}
		repeat
	else
		<len_delta> = (<net_whammy_length> - $prev_len)
		<len_base> = ($prev_len)
		Change prev_len = <net_whammy_length>
		<frames> = 5
		<Scale> = (1.0 / <frames>)
		<scale_step> = <Scale>
		begin
		<len> = (<len_base> + (<len_delta> * <Scale>))
		set_whammy_pitchshift control = <len> Player = <Player>
		<whammy_scale> = (((<len> * 0.5) + 0.5) * 2.0)
		SetNewWhammyValue value = <whammy_scale> time_remaining = <time> Player = <Player>
		<Scale> = (<Scale> + <scale_step>)
		Wait \{1
			gameframe}
		repeat <frames>
		begin
		set_whammy_pitchshift control = <net_whammy_length> Player = <Player>
		<whammy_scale> = (((<net_whammy_length> * 0.5) + 0.5) * 2.0)
		SetNewWhammyValue value = <whammy_scale> time_remaining = <time> Player = <Player>
		Wait \{1
			gameframe}
		repeat
	endif
endscript

script net_init 
	Change \{is_network_game = 1}
	SetNetworkMode \{$INTERNET_MODE}
	cleanup_sessionfuncs
	setup_sessionfuncs
	NetSessionFunc \{func = GetNumPlayers}
	spawn_player_drop_listeners
endscript

script wait_for_dw_init 
	begin
	if ($DEMONWARE_IS_READY = 1)
		break
	endif
	Wait \{1
		Frame}
	repeat
	add_active_controllers
	menu_net_matchmaking_init
	destroy_dialog_box
endscript

script add_active_controllers 
	GetActiveControllers
	GetArraySize <active_controllers>
	controller_index = 0
	begin
	if (<active_controllers> [<controller_index>] = 1)
		if CheckForSignIn controller_index = <controller_index>
			NetSessionFunc func = addcontrollers params = {controller = <controller_index>}
		endif
	endif
	<controller_index> = (<controller_index> + 1)
	repeat <array_Size>
endscript

script add_active_controllers_local 
	GetActiveControllers
	GetArraySize <active_controllers>
	controller_index = 0
	begin
	if (<active_controllers> [<controller_index>] = 1)
		if CheckForSignIn local controller_index = <controller_index>
			NetSessionFunc func = addcontrollers params = {controller = <controller_index>}
		endif
	endif
	<controller_index> = (<controller_index> + 1)
	repeat <array_Size>
endscript

script update_ingame_controllers 
	if musicstudio_mainobj :musicstudio_isinmusicstudio
		return
	endif
	if ($is_network_game = 0)
		if NOT ui_event_exists_in_stack \{Name = 'band_lobby'}
			if GotParam \{controller}
				NetSessionFunc \{func = removeallcontrollers}
				if IsArray <controller>
					GetArraySize <controller>
					if (<array_Size> > 0)
						<i> = 0
						begin
						<c> = (<controller> [<i>])
						NetSessionFunc func = addcontrollers params = {controller = <c>}
						<i> = (<i> + 1)
						repeat <array_Size>
					endif
				else
					NetSessionFunc func = addcontrollers params = {controller = <controller>}
				endif
			else
				add_active_controllers_local
			endif
		endif
	endif
endscript

script setup_online_player_settings 
	GetGlobalTags \{user_options}
	switch (<online_highway>)
		case 0
		setplayerinfo \{1
			highway_layout = default_highway}
		case 1
		setplayerinfo \{1
			highway_layout = solo_highway}
	endswitch
endscript

script start_network_game 
	if IsHost
		StartNetworkGame
	endif
endscript

script check_for_final_song_selection 
	if (($tie_breaker) = song_rand)
		return \{can_select_final_song = FALSE}
	elseif (($tie_breaker) = HOST)
		if IsHost
			return \{can_select_final_song = true}
		else
			return \{can_select_final_song = FALSE}
		endif
	elseif (($tie_breaker) = CLIENT)
		if IsHost
			return \{can_select_final_song = FALSE}
		else
			return \{can_select_final_song = true}
		endif
	endif
endscript

script online_fail_song 
	printf \{qs(0x34e995d3)}
	if ((GameIsOver) || (sessionisover))
		return
	endif
	netfailsong
endscript

script broadcast_received_winner_stats 
	setplayerinfo <Player> best_run = <note_streak>
	setplayerinfo <Player> total_notes = <total_notes>
	setplayerinfo <Player> notes_hit = <notes_hit>
endscript

script set_rich_presence_searching 
endscript

script set_rich_presence_game_mode 
	gamemode_gettype
	if ($is_network_game)
		Change \{rich_presence_context = presence_online}
	elseif ($rich_presence_context != presence_music_studio)
		switch <Type>
			case practice
			Change \{rich_presence_context = presence_practice}
			case tutorial
			Change \{rich_presence_context = presence_tutorial}
			case freeplay
			Change \{rich_presence_context = presence_party_play}
			case quickplay
			Change \{rich_presence_context = presence_quickplay}
			case career
			Change \{rich_presence_context = presence_career}
			case competitive
			Change \{rich_presence_context = presence_head_to_head}
		endswitch
	endif
endscript

script get_quick_match_search_params 
	ScriptAssert \{qs(0x26e58e31)}
endscript
bPS3SingleSignOnCheckComplete = 0

script xenon_singleplayer_session_init \{ps3_signin_callback = xenon_singleplayer_session_init}
	if CheckForSignIn
		NetSessionFunc \{func = stats_uninit}
		NetSessionFunc \{func = stats_init}
		NetSessionFunc \{func = motd_init}
		if isxenonorwindx
			NetSessionFunc \{func = start_singleplayer_session
				Obj = session}
		endif
		if NOT (<ps3_signin_callback> = xenon_singleplayer_session_init)
			printf \{qs(0x047b47b9)}
			<ps3_signin_callback>
		endif
	else
		if NOT isxenonorwindx
			if NOT GotParam \{from_callback}
				if (0 = $bPS3SingleSignOnCheckComplete)
					Change \{bPS3SingleSignOnCheckComplete = 1}
				endif
			else
				printf \{qs(0x2d9e8584)}
				Change \{ps3_signin_complete = 1}
			endif
		endif
	endif
endscript

script begin_singleplayer_game 
	if ($is_network_game = 1)
		if IsHost
			if NetSessionFunc \{Obj = session
					func = has_active_session}
				NetSessionFunc \{Obj = session
					func = begin_singleplayer_game}
			endif
		endif
	else
		if NetSessionFunc \{Obj = session
				func = has_active_session}
			NetSessionFunc \{Obj = session
				func = begin_singleplayer_game}
		endif
	endif
endscript

script end_singleplayer_game 
	if NetSessionFunc \{Obj = session
			func = has_active_session}
		NetSessionFunc \{Obj = session
			func = end_singleplayer_game}
	endif
	NetSessionFunc \{Obj = session
		func = end_party_session}
endscript

script deinit_all_for_invite 
	Change \{current_speedfactor = 1.0}
	setslomo \{$current_speedfactor}
endscript

script xenon_singleplayer_session_begin_uninit 
	if isxenonorwindx
		if NetSessionFunc \{Obj = session
				func = is_singleplayer_session}
			NetSessionFunc \{func = stop_singleplayer_session
				Obj = session}
		endif
	endif
endscript

script xenon_singleplayer_session_complete_uninit 
	if NOT GotParam \{song_failed}
		Wait \{3
			Seconds}
	endif
	NetSessionFunc \{Obj = session
		func = unpost_game}
endscript

script net_pausegh 
	printf \{qs(0x13c91937)}
	Change \{net_pause = 1}
	broadcastevent \{Type = event_pause_game}
	generic_event_choose \{state = Uistate_pausemenu}
	Wait \{1
		gameframe}
endscript

script net_unpausegh 
	printf \{qs(0x8609ed1f)}
	ui_event \{event = menu_back
		data = {
			state = Uistate_gameplay
		}}
	Wait \{1
		gameframe}
	Change \{net_pause = 0}
endscript

script create_net_popup \{title = qs(0x00000000)
		popup_text = qs(0x00000000)}
	destroy_net_popup
	Change \{net_popup_active = 1}
	create_dialog_box {
		dlg_z_priority = 10000
		heading_text = <title>
		body_text = <popup_text>
		dlg_z_priority = 5010
		no_background
		template = no_options
	}
endscript

script append_animating_dots 
	printf \{qs(0xcbc6ba89)}
	num_dots = 0
	if ScreenElementExists id = <id>
		begin
		formatText TextName = new_text qs(0x5994d4f6) a = <text> b = ($dots_array [<num_dots>])
		<id> :se_setprops text = <new_text>
		if (<num_dots> = 3)
			<num_dots> = 0
		else
			<num_dots> = (<num_dots> + 1)
		endif
		Wait \{0.5
			Second}
		repeat
	endif
endscript

script destroy_net_popup 
	Change \{net_popup_active = 0}
	destroy_dialog_box
endscript

script check_if_selecting_tie_breaker \{Player = 1}
	if IsHost
		if (($tie_breaker = HOST) && (<Player> = 1))
			return \{selecting_tiebreaker = 1}
		endif
		if (($tie_breaker = CLIENT) && (<Player> = 2))
			return \{selecting_tiebreaker = 1}
		endif
	else
		if (($tie_breaker = HOST) && (<Player> = 2))
			return \{selecting_tiebreaker = 1}
		endif
		if (($tie_breaker = CLIENT) && (<Player> = 1))
			return \{selecting_tiebreaker = 1}
		endif
	endif
	return \{selecting_tiebreaker = 0}
endscript

script test_events \{passed_in_value = 'test value'}
	printf \{qs(0x37c22cf4)}
	printstruct <...>
	NetSessionFunc \{Obj = stats
		func = write_key_value
		params = {
			wtf_value = 'test value'
			key = 'test key'
		}}
endscript

script scale_element_to_size \{time = 0}
	if NOT GotParam \{id}
		printf \{'Did not pass in id to scale_element_to_size! Returning'}
		return
	endif
	GetScreenElementDims id = <id>
	orig_height = <height>
	orig_width = <width>
	if NOT GotParam \{target_width}
		target_width = <orig_width>
	endif
	if NOT GotParam \{target_height}
		target_height = <orig_height>
	endif
	xScale = (<target_width> / (<orig_width> * 1.0))
	yScale = (<target_height> / (<orig_height> * 1.0))
	<id> :legacydomorph Scale = (<xScale> * (1.0, 0.0) + <yScale> * (0.0, 1.0)) time = <time>
endscript

script translate_screen_element \{time = 0}
	if NOT GotParam \{id}
		printf \{'Did not pass in id to translate_screen_element! Returning'}
		return
	endif
	if NOT GotParam \{Pos}
		GetScreenElementPosition id = <id>
		new_position = <screenelementpos>
	else
		new_position = <Pos>
	endif
	<id> :legacydomorph Pos = <new_position> time = <time>
endscript

script net_get_character_name \{Player = 1
		check_profanity = 1}
	RequireParams \{[
			Player
		]
		all}
	getplayerinfo <Player> character_id
	getplayerinfo <Player> character_savegame
	if (<check_profanity> = 1)
		get_fullname_of_character id = <character_id> savegame = <character_savegame>
	else
		get_fullname_of_character id = <character_id> savegame = <character_savegame> profanity_allowed
	endif
	printstruct <...>
	return display_name = <fullname> character_id = <character_id>
endscript

script fake_invite 
	if ($primary_controller = -1)
		Change \{primary_controller = 0}
	endif
	invite_accepted controllerid = ($primary_controller) fake_invite
endscript

script invite_accepted 
	if ScriptIsRunning \{do_join_invite_stuff}
		printf 'invite_accepted - replaced old invite for controller %c' c = ($invite_controller)
		KillSpawnedScript \{Name = do_join_invite_stuff}
	endif
	printf 'invite_accepted - controllerID %c' c = <controllerid>
	Change invite_controller = <controllerid>
	if ($primary_controller_assigned = 0)
		printf \{'invite_accepted - primary controller not yet assigned!'}
		printf \{qs(0x0d1bb516)}
		assign_new_primary_controller device_num = <controllerid>
	else
		printf 'invite_accepted - $primary_controller %p' p = ($primary_controller)
	endif
	do_join_invite_stuff <...> accepted_invite
endscript

script do_join_invite_stuff 
	printf \{'do_join_invite_stuff'}
	setscriptcannotpause
	if GotParam \{accepted_invite}
		Change g_leader_player_num = (<controllerid> + 1)
		if (($primary_controller_assigned = 1) && ($invite_controller = $primary_controller))
			<invited_primary_controller> = true
		else
			<invited_primary_controller> = FALSE
		endif
		printf qs(0x867bec5c) i = <invited_primary_controller>
		Change \{online_signin_autoload_required = 0}
		wait_for_safe_shutdown
		printf \{qs(0x1c9bd5e2)}
		disable_pause
		if ((isps3) || (isngc))
			NetSessionFunc \{Obj = party
				func = leave_party}
		else
			NetSessionFunc \{Obj = party
				func = stop_party_session}
		endif
		quit_network_game_early \{0x026d6679 = 1}
		begin
		if ($start_gem_scroller_running = 0)
			break
		elseif ($songtime_paused = 1)
			Change \{songtime_paused = 0}
		endif
		Wait \{1
			gameframe}
		repeat
		unpausespawnedscript \{ui_event_block}
		if (<invited_primary_controller> = true)
			create_loading_screen \{no_bink}
		endif
		ui_event_wait_for_safe
		if (($invite_controller) = -1)
			return
		endif
		gman_shutdowngamemodegoal
		career_end_challenge
		end_singleplayer_game
		if NOT GotParam \{fake_invite}
			if islocallysignedin controller = ($primary_controller)
				if CheckForSignIn controller_index = ($primary_controller)
					net_init
				endif
			endif
		endif
		Change \{has_invite_join_result_callback_completed = 0}
		StartRendering
		destroy_dialog_box
		if (<invited_primary_controller> = true)
			SetButtonEventMappings \{block_menu_input}
			ui_event_block \{event = menu_replace
				data = {
					state = uistate_mainmenu
					selected_index = 1
					clear_previous_stack
					ignore_camera = 1
				}}
			ui_event_remove_params \{param = ignore_camera}
			ui_event_remove_params \{param = state_device}
			SetButtonEventMappings \{unblock_menu_input}
		else
			UnPauseGame
			ui_event_block {
				event = menu_replace
				data = {
					state = uistate_signin
					device_num = ($invite_controller)
					clear_previous_stack
					new_state = uistate_invite_continue
					new_data = {
						controllerid = ($invite_controller)
					}
				}
			}
			ui_event_remove_params \{param = state_device}
			return
		endif
		if NOT NetSessionFunc func = iscontrolleringame params = {controller = ($invite_controller)}
			NetSessionFunc func = addcontrollers params = {controller = ($invite_controller)}
		endif
		xenon_singleplayer_session_begin_uninit
		deinit_all_for_invite
		UnPauseGame
		<controller_idx> = 0
		begin
		if NetSessionFunc func = iscontrolleringame params = {controller = <controller_idx>}
			if CheckForSignIn controller_index = <controller_idx>
				if NetSessionFunc func = ismultiplayerallowed params = {controller_index = <controller_idx>}
				else
					printf 'do_join_invite_stuff - removed controller %c, signed in but not multiplayer enabled' c = <controller_idx>
					NetSessionFunc func = removecontroller params = {controller = <controller_idx>}
				endif
			else
				printf 'do_join_invite_stuff - removed controller %c, not signed in' c = <controller_idx>
				NetSessionFunc func = removecontroller params = {controller = <controller_idx>}
			endif
		endif
		<controller_idx> = (<controller_idx> + 1)
		repeat 4
		if GotParam \{fake_invite}
			destroy_loading_screen
			ui_event_block \{event = menu_replace
				data = {
					state = uistate_mainmenu
					base_name = 'mainmenu'
					selected_index = 3
					clear_previous_stack
				}}
			ui_event_remove_params \{param = state_device}
		else
			JoinInviteServer
		endif
	else
		printf \{'do_join_invite_stuff - not accepted'}
		ui_event_block \{event = menu_replace
			data = {
				state = uistate_mainmenu
				base_name = 'mainmenu'
				selected_index = 3
				clear_previous_stack
			}}
		ui_event_remove_params \{param = state_device}
	endif
endscript

script menu_show_gamercard 
	if NOT (($is_network_game) && (isxenonorwindx))
		return
	endif
	retrieve_player_net_id \{Player = 2}
	NetSessionFunc func = showGamerCard params = {player_xuid = <net_id>}
endscript

script menu_show_gamercard_from_netid 
	RequireParams \{[
			device_num
		]
		all}
	if CheckForSignIn controller_index = <device_num>
		if NOT ($is_network_game = 1)
			return
		endif
		if GotParam \{net_id}
			NetSessionFunc func = showGamerCard params = {player_xuid = <net_id> controller_index = <device_num>}
		endif
	endif
endscript

script win_now 
	ExtendCrc \{song_won
		'p1'
		out = Type}
	broadcastevent Type = <Type>
endscript
new_message_of_the_day = 0

script splash_callback 
	printf \{qs(0x7cd3e629)}
	printstruct <...>
	if GotParam \{motd_text}
		Change \{new_message_of_the_day = 1}
	else
		Change \{new_message_of_the_day = 0}
	endif
endscript

script RemoveObserverBG 
endscript

script net_disable_pause 
	if NOT GotParam \{no_unpause}
		if ($net_pause = 1)
			net_unpausegh
		endif
	endif
	disable_pause
endscript

script net_fail_coop_song 
	printf \{qs(0x4a48ff2b)}
	Skate8_SFX_Backgrounds_New_Area \{BG_SFX_Area = FrontEnd
		fadeintime = 5
		fadeintype = linear
		fadeouttime = 5
		fadeouttype = linear}
	net_disable_pause
	Change \{recovered_dropped_players = 0}
	Change \{net_num_players_data_ack = 0}
	if (IsHost)
		i = 1
		getnumplayersingame \{on_screen
			local}
		if (<num_players_shown> > 0)
			getfirstplayer \{on_screen
				local}
			begin
			Change net_num_players_data_ack = ($net_num_players_data_ack + 1)
			getnextplayer on_screen local Player = <Player>
			repeat <num_players_shown>
		endif
		GetNumPlayers
		Change net_num_players_data_needed = <num_players>
		getbandinfo \{1
			score}
		SendStructure callback = set_client_band_score data_to_send = {band_score = <score>}
	else
		player_data = {}
		getnumplayersingame \{on_screen
			local}
		if (<num_players_shown> > 0)
			getfirstplayer \{on_screen
				local}
			begin
			formatText checksumName = player_info 'player%d_info' d = <Player>
			getplayerinfo <Player> net_obj_id
			getplayerinfo <Player> score
			getplayerinfo <Player> best_run
			getplayerinfo <Player> max_notes
			getplayerinfo <Player> notes_hit
			getplayerinfo <Player> stars
			getplayerinfo <Player> vocal_streak_phrases
			getplayerinfo <Player> vocal_phrase_quality
			getplayerinfo <Player> vocal_phrase_max_qual
			getplayerinfo <Player> total_notes
			appendstruct {
				struct = player_data
				Field = <player_info>
				params = {
					obj_id = <net_obj_id>
					score = <score>
					best_run = <best_run>
					max_notes = <max_notes>
					notes_hit = <notes_hit>
					stars = <stars>
					vocal_streak_phrases = <vocal_streak_phrases>
					vocal_phrase_quality = <vocal_phrase_quality>
					vocal_phrase_max_qual = <vocal_phrase_max_qual>
					total_notes = <total_notes>
				}
			}
			getnextplayer on_screen local Player = <Player>
			repeat <num_players_shown>
		endif
		SendStructure callback = player_data_request_ack data_to_send = {player_data = <player_data>} to_server
	endif
	KillSpawnedScript \{Name = GuitarEvent_SongWon_Spawned}
	SpawnScriptNow \{GuitarEvent_SongFailed_Spawned}
endscript

script set_client_band_score 
	if GotParam \{band_score}
		printf qs(0x9f6fe397) s = <band_score>
		setbandinfo 1 score = <band_score>
	endif
endscript

script add_searching_menu_item \{z = 2.1}
	if GotParam \{vmenu_id}
		CreateScreenElement {
			Type = ContainerElement
			parent = <vmenu_id>
			dims = (210.0, 35.0)
			Pos = (0.0, 0.0)
			just = [center top]
			internal_just = [center top]
		}
		<container_element> = <id>
		<id> :se_setprops {
			event_handlers = [
				{focus searching_menu_focus params = {parent = <id>}}
				{unfocus searching_menu_unfocus params = {parent = <id>}}
				{pad_choose <choose_script>}
			]
		}
		CreateScreenElement {
			Type = TextElement
			parent = <container_element>
			local_id = text_string
			font = fontgrid_title_a1
			Scale = 0.65000004
			rgba = ($online_light_blue)
			text = <text>
			just = [center top]
			Pos = (105.0, 0.0)
			z_priority = <z>
		}
		CreateScreenElement {
			Type = SpriteElement
			parent = <container_element>
			local_id = highlight_bar
			texture = white
			dims = (250.0, 35.0)
			rgba = ($online_light_blue)
			Pos = (105.0, -3.0)
			just = [center top]
			z_priority = <z>
			alpha = 0.0
		}
		CreateScreenElement {
			Type = SpriteElement
			parent = <container_element>
			local_id = left_bookend
			texture = character_hub_hilite_bookend
			dims = (35.0, 35.0)
			rgba = ($online_light_blue)
			Pos = (-20.0, -3.0)
			just = [center top]
			z_priority = <z>
			alpha = 0.0
		}
		CreateScreenElement {
			Type = SpriteElement
			parent = <container_element>
			local_id = right_bookend
			texture = character_hub_hilite_bookend
			dims = (35.0, 35.0)
			rgba = ($online_light_blue)
			Pos = (240.0, -3.0)
			just = [center top]
			z_priority = <z>
			alpha = 0.0
		}
	endif
endscript

script searching_menu_focus 
	Obj_GetID
	if ScreenElementExists id = {<objID> child = text_string}
		legacydoscreenelementmorph id = {<objID> child = text_string} rgba = ($online_dark_purple)
	endif
	if ScreenElementExists id = {<objID> child = highlight_bar}
		legacydoscreenelementmorph id = {<objID> child = highlight_bar} alpha = 1.0
	endif
	if ScreenElementExists id = {<objID> child = left_bookend}
		legacydoscreenelementmorph id = {<objID> child = left_bookend} alpha = 1.0
	endif
	if ScreenElementExists id = {<objID> child = right_bookend}
		legacydoscreenelementmorph id = {<objID> child = right_bookend} alpha = 1.0
	endif
endscript

script searching_menu_unfocus 
	Obj_GetID
	if ScreenElementExists id = {<objID> child = text_string}
		legacydoscreenelementmorph id = {<objID> child = text_string} rgba = ($online_light_blue)
	endif
	if ScreenElementExists id = {<objID> child = highlight_bar}
		legacydoscreenelementmorph id = {<objID> child = highlight_bar} alpha = 0.0
	endif
	if ScreenElementExists id = {<objID> child = left_bookend}
		legacydoscreenelementmorph id = {<objID> child = left_bookend} alpha = 0.0
	endif
	if ScreenElementExists id = {<objID> child = right_bookend}
		legacydoscreenelementmorph id = {<objID> child = right_bookend} alpha = 0.0
	endif
endscript

script retrieve_player_net_id 
	net_id = [0 0]
	if GotParam \{Player}
		getplayerinfo <Player> net_id_first
		getplayerinfo <Player> net_id_second
	else
		getfirstplayer
		getplayerinfo <Player> net_id_first
		getplayerinfo <Player> net_id_second
	endif
	SetArrayElement ArrayName = net_id index = 0 NewValue = <net_id_first>
	SetArrayElement ArrayName = net_id index = 1 NewValue = <net_id_second>
	printf \{qs(0xa9796959)}
	return net_id = <net_id>
endscript

script scale_element_width_to_size \{max_text_width = 400}
	if NOT GotParam \{id}
		return
	endif
	GetScreenElementDims id = <id>
	if (<width> > <max_text_width>)
		SetScreenElementProps {
			id = <id>
			Scale = ((1.0, 0.0) + (0.0, 1.0) * (<text_scale>.(0.0, 1.0)))
		}
		scale_element_to_size {
			id = <id>
			target_width = <max_text_width>
		}
	endif
endscript

script fit_text_into_menu_item 
	if ScreenElementExists id = <id>
		GetScreenElementDims id = <id>
		if (<width> > <max_width>)
			SetScreenElementProps {
				id = <id>
				Scale = 1.0
			}
			scale_element_to_size {
				id = <id>
				target_width = <max_width>
				target_height = <height>
			}
		endif
	endif
endscript

script net_coop_init_star_power 
	printf \{qs(0x188cbe2c)}
	getplayerinfo \{1
		star_power_used
		out = star_power_used1}
	getplayerinfo \{2
		star_power_used
		out = star_power_used2}
	if NOT ((<star_power_used1> = 1) || (<star_power_used2> = 1))
		SpawnScriptNow \{star_power_activate_and_drain
			params = {
				Player = 1
			}}
		SpawnScriptNow \{star_power_activate_and_drain
			params = {
				Player = 2
			}}
	endif
endscript
DEMONWARE_IS_READY = 1
demonware_stun_failed = 0
demonware_connection_success = 0

script set_ready_for_input 
	Change \{DEMONWARE_IS_READY = 1}
	Change \{demonware_stun_failed = 0}
	Change \{demonware_connection_success = 1}
endscript

script set_demonware_failed 
	Change \{DEMONWARE_IS_READY = 1}
	Change \{demonware_stun_failed = 1}
	Change \{demonware_connection_success = 0}
endscript

script set_disable_demonware_input 
	Change \{DEMONWARE_IS_READY = 0}
endscript

script 0x38a976eb 
	display = 1
	get_savegame_from_controller \{controller = $primary_controller}
	if NOT is_autosave_on savegame = <savegame>
		<display> = 0
	endif
	if NOT was_acceptable_string
		<display> = 0
	endif
	if NOT NetSessionFunc \{func = can_view_user_content}
		<display> = 0
	endif
	if NOT CheckForSignIn \{controller_index = 0
			dont_set_primary
			network_platform_only}
		<display> = 0
	endif
	if (<display> = 1)
		displaynotification ($wii_notification_strings.connected_to_gameservers)
	endif
endscript

script online_end_song 
	printf \{qs(0xdf6f59ee)}
	if ((GameIsOver) || (sessionisover))
		printf \{qs(0x27fd2f0c)}
		return
	endif
	Change \{net_num_players_data_ack = 0}
	Change \{recovered_dropped_players = 0}
	if (IsHost)
		SendEndSong
		client_handle_end_song
	endif
	printf qs(0x8110ad7a) d = ($net_num_players_data_ack)
endscript

script client_handle_end_song 
	printf \{qs(0xb4527a20)}
	ExtendCrc \{song_won
		'p1'
		out = Type}
	broadcastevent Type = <Type>
	gamemode_gettype
	Change \{recovered_dropped_players = 0}
endscript

script player_data_request_ack 
	printf \{qs(0xb13dabc7)}
endscript

script finish_player_data_sync 
endscript

script net_load_preferences 
	netoptions :pref_add \{Name = private_slots
		array = $num_private_slots
		index = 0
		value_field = num
		display_string_field = Name}
	netoptions :pref_add \{Name = Ranked
		array = $ranked_info
		index = 0
		display_string_field = Name}
	netoptions :pref_add \{Name = join_in_progress
		array = $join_in_progress_info
		index = 0
		value_field = num
		display_string_field = Name}
	netoptions :pref_add \{Name = num_players
		array = $num_players_info
		index = 1
		value_field = num
		display_string_field = Name}
	if ($is_multiplayer_beta = 0)
		netoptions :pref_add \{Name = game_modes
			array = $net_game_type_info
			index = 0
			display_string_field = Name}
	else
		netoptions :pref_add \{Name = game_modes
			array = $beta_net_game_type_info
			index = 0
			display_string_field = Name}
	endif
endscript

script new_net_player 
	printf \{qs(0xcc13a237)}
	formatText checksumName = gamertag_global 'gamertag_%d' d = (<player_num> - 1)
	printstruct <...>
	Change GlobalName = <gamertag_global> NewValue = <gamertag_string>
	setplayerinfo <player_num> gamertag = <gamertag_global>
	setplayerinfo <player_num> net_id_first = <net_id_first>
	setplayerinfo <player_num> net_id_second = <net_id_second>
	setplayerinfo <player_num> is_local_client = <local_client>
	setplayerinfo <player_num> net_obj_id = <obj_id>
	setplayerinfo <player_num> part = <part>
	setplayerinfo <player_num> Band = <Band>
	setplayerinfo <player_num> in_game = 1
	setplayerinfo <player_num> difficulty = <difficulty>
	setplayerinfo <player_num> is_onscreen = <player_on_screen>
	setplayerinfo <player_num> console_id = <console_id>
	if (<local_client> = 1)
		transfer_controller_value_for_local_player <...>
	else
		setplayerinfo <player_num> controller = 5
	endif
	setbandinfo <Band> in_game = 1
endscript

script adjust_rest_of_on_stage_characters 
	gamemode_gettype
	if ((<Type> != quickplay) && (<Type> != competitive) && (<Type> != career))
		return
	endif
	if NOT ininternetmode
		return
	endif
	getnumplayersingame \{out = num_players}
	if (<num_players> >= 4)
		return
	endif
	get_player_infos_in_use
	begin
	RemoveParameter \{found_player}
	GetArraySize <player_infos_in_use>
	i = 0
	begin
	Player = (<player_infos_in_use> [<i>])
	getplayerinfo <Player> in_game
	if (<in_game> = 0)
		getplayerinfo <Player> stored_character_index
		if (<stored_character_index> = 0)
			found_player = <Player>
			break
		endif
	endif
	<i> = (<i> + 1)
	repeat <array_Size>
	if GotParam \{found_player}
		RemoveParameter \{found_index}
		i = 1
		begin
		GetArraySize <player_infos_in_use>
		j = 0
		begin
		Player = (<player_infos_in_use> [<j>])
		getplayerinfo <Player> in_game
		if (<in_game> = 0)
			getplayerinfo <Player> stored_character_index
			if (<stored_character_index> = <i>)
				break
			endif
		endif
		<j> = (<j> + 1)
		repeat <array_Size>
		if (<j> = <array_Size>)
			found_index = <i>
			break
		endif
		<i> = (<i> + 1)
		repeat 3
		if GotParam \{found_index}
			setplayerinfo <found_player> stored_character_index = <found_index>
			if ($g_leader_player_num > 0)
				savegame_player = ($g_leader_player_num)
			else
				savegame_player = <found_player>
			endif
			get_savegame_from_player Player = <savegame_player>
			get_saved_band_member index = <found_index> savegame = <savegame>
			if NOT characterprofileexists savegame = <character_savegame> Name = <character_id>
				setplayerinfo <found_player> character_id = ($failsafe_car_profile)
				setplayerinfo <found_player> character_savegame = <savegame>
			else
				setplayerinfo <found_player> character_id = <character_id>
				setplayerinfo <found_player> character_savegame = <character_savegame>
			endif
		endif
	else
		break
	endif
	repeat 4
endscript

script adjust_rest_of_on_stage_characters_and_instruments 
	gamemode_gettype
	if ((<Type> != quickplay) && (<Type> != competitive) && (<Type> != career))
		return
	endif
	if NOT ininternetmode
		return
	endif
	getnumplayersingame \{out = num_players}
	if (<num_players> >= 4)
		return
	endif
	instruments_we_need = []
	GetArraySize ($part_priority)
	if (<array_Size> > 0)
		i = 0
		begin
		item = {part = ($part_priority [<i>])}
		AddArrayElement array = <instruments_we_need> element = <item>
		<instruments_we_need> = <array>
		i = (<i> + 1)
		repeat <array_Size>
	endif
	getfirstplayer \{out = Player}
	begin
	getplayerinfo <Player> part
	found = -1
	GetArraySize \{instruments_we_need}
	if (<array_Size> > 0)
		i = 0
		begin
		if ((<found> = -1) && (<part> = (<instruments_we_need> [<i>].part)))
			found = <i>
			break
		endif
		i = (<i> + 1)
		repeat <array_Size>
	endif
	if (<found> != -1)
		RemoveArrayElement array = <instruments_we_need> index = <found>
		<instruments_we_need> = <array>
	endif
	getnextplayer Player = <Player> out = Player
	repeat <num_players>
	Player = 1
	dirty = 0
	begin
	getplayerinfo <Player> in_game
	if (<in_game> = 0)
		GetArraySize \{instruments_we_need}
		if (<array_Size> > 0)
			setplayerinfo <Player> part = (<instruments_we_need> [0].part)
			RemoveArrayElement array = <instruments_we_need> index = 0
			<instruments_we_need> = <array>
			dirty = 1
		endif
	endif
	Player = (<Player> + 1)
	repeat 4
	if (<dirty> = 1)
	endif
endscript

script net_start_character_silhouette 
	RequireParams \{[
			Player
		]
		all}
	printf \{qs(0xba320f4c)}
	formatText checksumName = submenu_data 'band_lobby_submenu_data_%i' i = <submenu_index>
	setplayerinfo <Player> chosen_character_id = silhouette
	setplayerinfo <Player> chosen_character_savegame = -1
endscript

script net_stop_character_silhouette 
	RequireParams \{[
			Player
		]
		all}
	printf \{qs(0xc3035321)}
	setplayerinfo <Player> chosen_character_id = None
	setplayerinfo <Player> chosen_character_savegame = -1
endscript

script check_for_net_appearance_arrival 
	RequireParams \{[
			Player
		]
		all}
	begin
	getplayerinfo <Player> chosen_character_id
	if checksumequals a = <chosen_character_id> b = None
		break
	elseif net_appearance_is_valid Player = <Player>
		net_stop_character_silhouette Player = <Player>
		break
	endif
	Wait \{0.5
		Seconds}
	repeat
endscript

script net_appearance_is_valid 
	RequireParams \{[
			Player
		]
		all}
	getplayerinfo <Player> character_id
	switch (<character_id>)
		case temporary_netprofile_0
		case temporary_netprofile_1
		case temporary_netprofile_2
		case temporary_netprofile_3
		case temporary_netprofile_4
		case temporary_netprofile_5
		case temporary_netprofile_6
		case temporary_netprofile_7
		return \{true}
		default
		return \{FALSE}
	endswitch
endscript

script host_proceed_to_online_play 
	printf \{qs(0xb2b28b68)}
	StartNetworkGame
endscript

script setautolaunchhostnetlevel 
	printf \{qs(0xb5e0a9a1)}
	Change \{net_autolaunch_role = HOST}
endscript

script setautolaunchclient 
	printf \{qs(0xc9e66c76)}
	Change \{net_autolaunch_role = CLIENT}
endscript

script net_custom_guide_view_user_songs 
	printf \{qs(0xa819dc71)}
	printstruct <...>
	printscriptinfo
endscript

script get_controller_type 
	if NOT GotParam \{controller_index}
		return \{controller_type = controller}
	endif
	getcontrollertype controller = <controller_index>
	return controller_type = <controller_type>
endscript

script get_local_in_game_player_num_from_controller 
	RequireParams \{[
			controller_index
		]
		all}
	getnumplayersingame \{local}
	if (<num_players> > 0)
		getfirstplayer \{local}
		max_controller_index = 3
		if isps3
			max_controller_index = 6
		endif
		begin
		getplayerinfo <Player> bot_play
		getplayerinfo <Player> bot_original_controller
		if ((<bot_play> = 1) && ((<bot_original_controller> >= 0) && (<bot_original_controller> <= <max_controller_index>)))
			if playerinfoequals <Player> bot_original_controller = <controller_index>
				return player_num = <Player>
			endif
		else
			if playerinfoequals <Player> controller = <controller_index>
				return player_num = <Player>
			endif
		endif
		getnextplayer Player = <Player> local
		repeat <num_players>
	endif
	return \{player_num = -1}
endscript

script get_player_num_from_controller 
	RequireParams \{[
			controller_index
		]
		all}
	num_local_controllers = 4
	player_num = -1
	i = 1
	begin
	getplayerinfo <i> controller
	if (<controller_index> = <controller>)
		player_num = <i>
		break
	endif
	i = (<i> + 1)
	repeat <num_local_controllers>
	return player_num = <player_num>
endscript

script get_local_player_num_from_controller 
	RequireParams \{[
			controller_index
		]
		all}
	num_local_controllers = 4
	Player = 1
	begin
	getplayerinfo <Player> controller
	if (<controller_index> = <controller>)
		break
	endif
	Player = (<Player> + 1)
	repeat <num_local_controllers>
	return local_player_num = <Player>
endscript

script net_dummy_get_needed_search_params 
	if ($g_band_lobby_flag = 1)
		if ($g_lobby_state = career)
			guitars = 2
			drums = 1
			microphones = 1
			scoring_mode = career
		elseif ($g_lobby_state = quickplay)
			guitars = 2
			drums = 1
			microphones = 1
			scoring_mode = coop
		elseif ($g_lobby_state = vs)
			guitars = 1
			drums = 0
			microphones = 0
			scoring_mode = competitive
		endif
	else
		if ($game_mode = gh4_p4_career)
			guitars = 2
			drums = 1
			microphones = 1
			scoring_mode = career
		else
			guitars = 1
			drums = 0
			microphones = 0
			scoring_mode = competitive
		endif
	endif
	return needed_guitars = <guitars> needed_drums = <drums> needed_microphones = <microphones> scoring_mode = <scoring_mode>
endscript

script net_get_player_instrument 
	RequireParams \{[
			controller_index
		]
		all}
	get_controller_type controller_index = <controller_index>
	rb_drums = 0
	if checksumequals a = <controller_type> b = drum
		if isrbdrum controller = <controller_index>
			rb_drums = 1
		endif
	endif
	return instrument = <controller_type> <...>
endscript

script net_get_player_guitar_flag 
	printf \{qs(0xde0d8e43)}
	RequireParams \{[
			controller_index
		]
		all}
	get_local_in_game_player_num_from_controller controller_index = <controller_index>
	getplayerinfo <player_num> part
	if (<part> = bass)
		return \{flag = 1}
	else
		return \{flag = 0}
	endif
endscript

script net_get_player_cash 
	return \{career_cash = 0}
endscript

script net_get_player_difficulty 
	RequireParams \{[
			controller_index
		]
		all}
	get_local_in_game_player_num_from_controller controller_index = <controller_index>
	if (<player_num> != -1)
		getplayerinfo <player_num> difficulty
	else
		printf \{qs(0x87ee2a4c)}
		difficulty = easy
	endif
	return difficulty = <difficulty>
endscript

script get_local_players_in_game 
	printf \{qs(0xfccab215)}
	if NOT isps3
		max_local_players = 4
	else
		max_local_players = 7
	endif
	i = 0
	array = []
	num_local_players = 0
	begin
	NetSessionFunc func = iscontrolleringame params = {controller = <i>}
	if GotParam \{isingame}
		AddArrayElement array = <array> element = 1
		num_local_players = (<num_local_players> + 1)
		RemoveParameter \{isingame}
	else
		AddArrayElement array = <array> element = 0
	endif
	i = (<i> + 1)
	repeat <max_local_players>
	return local_players = <array> num_local_players = <num_local_players>
endscript

script transfer_controller_value_for_local_player 
	printf \{qs(0x70e88519)}
	if isps3
		num_local_controllers = 7
	else
		num_local_controllers = 4
	endif
	<player_found> = 0
	i = 0
	begin
	if (($temp_net_id [<i>].net_id_first) = <net_id_first> && ($temp_net_id [<i>].net_id_second) = <net_id_second>)
		if ((isps3) || (isngc))
			if LocalizedStringEquals a = ($temp_net_id [<i>].Name) b = <gamertag_string>
				<player_found> = 1
			endif
		else
			<player_found> = 1
		endif
		if (<player_found> = 1)
			setplayerinfo <player_num> controller = <i>
			setplayerinfo <player_num> lefty_flip = ($temp_net_id [<i>].lefty_flip)
			setplayerinfo <player_num> mic_type = ($temp_net_id [<i>].mic_type)
			setplayerinfo <player_num> mic_preference = ($temp_net_id [<i>].mic_preference)
			setplayerinfo <player_num> character_id = ($temp_net_id [<i>].character_id)
			setplayerinfo <player_num> character_savegame = ($temp_net_id [<i>].character_savegame)
			setplayerinfo <player_num> double_kick_drum = ($temp_net_id [<i>].double_kick)
			setplayerinfo <player_num> difficulty = ($temp_net_id [<i>].difficulty)
			setplayerinfo <player_num> stored_character_index = ($temp_net_id [<i>].stored_character_index)
			setplayerinfo <player_num> part = ($temp_net_id [<i>].part)
			setplayerinfo <player_num> Cheat_Hyperspeed = ($temp_net_id [<i>].Cheat_Hyperspeed)
			setplayerinfo <player_num> cheat_hyperspeed_value = ($temp_net_id [<i>].cheat_hyperspeed_value)
			setplayerinfo <player_num> vocals_highway_view = ($temp_net_id [<i>].vocals_highway_view)
			setplayerinfo <player_num> enable_touch_strip = ($temp_net_id [<i>].enable_touch_strip)
			setplayerinfo <player_num> use_tilt_for_starpower = ($temp_net_id [<i>].use_tilt_for_starpower)
			break
		endif
	endif
	i = (<i> + 1)
	repeat <num_local_controllers>
	if (<player_found> = 0)
		setplayerinfo <player_num> controller = 3
	endif
endscript

script net_choose_gamemode_from_players 
	printf \{qs(0x330f85fe)}
	gamemode_gettype
	printstruct <...>
	if checksumequals a = <Type> b = career
		printf \{qs(0xd1270c2d)}
		gamemode_updatenumplayers num_players = <total_players>
		gamemode_setteamsize team_size = <total_players>
	elseif checksumequals a = <Type> b = quickplay
		printf \{qs(0x4e077ebc)}
		switch <total_players>
			case 2
			printf \{qs(0x09c32524)}
			Change \{game_mode = p2_quickplay}
			case 3
			printf \{qs(0x10d81465)}
			Change \{game_mode = p3_quickplay}
			case 4
			printf \{qs(0x5f9982a2)}
			if (($game_mode) = p4_quickplay)
				printf qs(0xc4b880c5) d = <total_players>
			else
				printf qs(0xc9525aaa) d = ($game_mode)
				Change \{game_mode = p4_quickplay}
			endif
			default
			printf qs(0xc4b880c5) d = <total_players>
		endswitch
		gamemode_updatenumplayers num_players = <total_players>
	elseif checksumequals a = <Type> b = pro_faceoff
		gamemode_updatenumplayers num_players = <total_players>
	elseif checksumequals a = <Type> b = competitive
		gamemode_updatenumplayers num_players = <total_players>
	elseif checksumequals a = <Type> b = trivia
		gamemode_updatenumplayers num_players = <total_players>
	endif
	if checksumequals \{a = $game_mode
			b = p8_pro_faceoff}
		if NOT (<total_players> = 8)
			if NOT (<total_players> = 6)
				ScriptAssert 'trying to play band v band with %d playes (only 8 or 6 with no mics allowed)!' d = <total_players>
			endif
			printf \{qs(0x7f593fba)}
			Change \{game_mode = p6_pro_faceoff_no_mics}
		else
			printf qs(0xc4b880c5) d = <total_players>
		endif
	endif
endscript

script wait_for_net_popup 
	begin
	if ($net_popup_active = 0)
		break
	endif
	Wait \{1
		gameframe}
	repeat
endscript

script do_ps3_signin_state_change 
	printf \{qs(0x05f43ed9)}
	printstruct <...>
	if GotParam \{age_restricted}
		ui_event_wait event = menu_replace data = {state = <state> <params> require_live}
	elseif CheckForSignIn
		if GotParam \{going_to_career}
			Change \{game_mode = gh4_p4_career}
			netoptions :pref_choose \{Name = game_modes
				checksum = gh4_p4_career}
		endif
		NetSessionFunc \{func = stats_init}
		NetSessionFunc \{func = motd_uninit}
		NetSessionFunc \{func = motd_init}
		NetSessionFunc \{func = live_settings_init}
		ui_event_wait event = menu_replace state = $signin_continue_state data = ($signin_continue_data)
	else
		ui_event_wait event = menu_replace data = {state = <state> <params> require_live}
	endif
endscript

script uisignin_motd_callback 
	printf \{qs(0xd00b2987)}
	if GotParam \{success}
		printf qs(0x2bbcd37a) d = ($motd_header)
		printf qs(0xa3db5484) d = ($motd_subject)
	else
		printf \{qs(0xce10362f)}
	endif
	printstruct <...>
endscript

script retrieved_live_settings_file 
	if ($net_should_allow_motd = 1)
		NetSessionFunc \{func = get_demonware_motd
			Obj = motd
			params = {
				callback = uisignin_motd_callback
			}}
	endif
endscript

script start_data_sync 
	printf \{qs(0xe53f810c)}
	RequireParams \{[
			params
			parent_id
			require_ack
		]
		all}
	if IsHost
		if ScreenElementExists id = <parent_id>
			GetNumPlayers
			create_data_sync_container_and_tags parent_id = <parent_id> data_set_id = (<params>.data_set_id) data_type = (<params>.data_type)
			(<params>.data_set_id) :Obj_SpawnScriptNow wait_for_data_sync_ack params = {require_ack = <require_ack> wait_time = <wait_time>}
			SendStructure callback = data_sync_request data_to_send = <params>
			data_sync_request data_set_id = (<params>.data_set_id) data_type = (<params>.data_type) local = 1
		else
			printf \{qs(0x3ce1407d)}
		endif
	endif
endscript

script wait_for_data_sync_ack \{wait_time = 5.0}
	printf \{qs(0x76f0f4f2)}
	if (<require_ack> = 1)
		wait_time = (<wait_time> / 2)
		printf qs(0x2acca455) d = <wait_time>
	endif
	Obj_GetID
	wait_for_ack_loop objID = <objID> wait_time = <wait_time>
	printf \{qs(0x3d79b748)}
	GetTags
	switch <data_type>
		case player_info
		getnumplayersingame
		if (<num_players> > 0)
			getfirstplayer
			begin
			formatText checksumName = player_struct_id 'player%d' d = <Player>
			if StructureContains structure = <player_data> <player_struct_id>
				SendStructure callback = finalize_data_sync data_to_send = {data = (<player_data>.<player_struct_id>.data) player_num = <Player> data_set_id = <data_set_id> data_type = <data_type>}
				finalize_data_sync data = (<player_data>.<player_struct_id>.data) player_num = <Player> data_set_id = <data_set_id> data_type = <data_type> local = 1
			endif
			getnextplayer Player = <Player>
			repeat <num_players>
		endif
		case Global
		printf \{qs(0x950943f7)}
		case apearance_data
	endswitch
	if (<require_ack> = 1)
		SetTags \{player_acks = [
				0
				0
				0
				0
				0
				0
				0
				0
			]}
		SendStructure callback = finalize_data_sync data_to_send = {data = {require_ack = 1} data_set_id = <data_set_id>}
		finalize_data_sync data = {require_ack = 1} data_set_id = <data_set_id> local = 1
		wait_for_ack_loop objID = <objID> wait_time = <wait_time>
		printf \{qs(0x79b813b8)}
	endif
	Die
endscript

script data_sync_ack 
	printf \{qs(0xb933afcc)}
	RequireParams \{[
			player_num
			data_set_id
		]
		all}
	if ScreenElementExists id = <data_set_id>
		formatText checksumName = Player 'player%d' d = <player_num>
		<data_set_id> :GetTags
		if GotParam \{data}
			appendstruct {
				struct = player_data
				Field = <Player>
				params = {data = <data>}
			}
			<data_set_id> :SetTags player_data = <player_data>
		endif
		SetArrayElement ArrayName = player_acks index = (<player_num> - 1) NewValue = 1
		<data_set_id> :SetTags player_acks = <player_acks>
	else
		printf \{qs(0x05d64dd3)}
	endif
endscript

script data_sync_request \{local = 0}
	printf \{qs(0x4bc48c4d)}
	RequireParams \{[
			data_set_id
			data_type
		]
		all}
	GetArraySize ($<data_set_id>)
	if (0 < <array_Size>)
		getnumplayersingame
		if (<num_players> > 0)
			getfirstplayer
			begin
			array = []
			player_data = {}
			getplayerinfo <Player> is_local_client
			getplayerinfo <Player> net_obj_id
			if ((<is_local_client> = 1) && (<net_obj_id> >= 0))
				index = 0
				begin
				switch <data_type>
					case player_info
					getplayerinfo <Player> ($<data_set_id> [<index>]) out = value
					case Global
					value = ($<data_set_id> [<index>])
					value = ($<value>)
					case apearance_data
				endswitch
				printf qs(0xd05a6fe1) d = <Player> c = ($<data_set_id> [<index>]) v = <value>
				appendstruct {
					struct = player_data
					Field = ($<data_set_id> [<index>])
					params = {value = <value>}
				}
				AddArrayElement array = <array> element = <value>
				index = (<index> + 1)
				repeat <array_Size>
				if (<local>)
					data_sync_ack player_num = <Player> data_set_id = <data_set_id> data = <player_data>
				else
					SendStructure callback = data_sync_ack data_to_send = {player_num = <Player> data_set_id = <data_set_id> data = <player_data>}
				endif
			endif
			getnextplayer Player = <Player>
			repeat <num_players>
		endif
	endif
endscript

script finalize_data_sync \{local = 0}
	printf \{qs(0x90f79d77)}
	RequireParams \{[
			data
		]
		all}
	GetArraySize ($<data_set_id>)
	if (<array_Size> > 0)
		index = 0
		begin
		if StructureContains structure = <data> require_ack
			getnumplayersingame
			if (<num_players> > 0)
				getfirstplayer
				begin
				getplayerinfo <Player> is_local_client
				getplayerinfo <Player> net_obj_id
				if ((<is_local_client> = 1) && (<net_obj_id> >= 0))
					index = 0
					if (<local>)
						data_sync_ack player_num = <Player> data_set_id = <data_set_id>
					else
						SendStructure callback = data_sync_ack data_to_send = {player_num = <Player> data_set_id = <data_set_id>}
					endif
				endif
				getnextplayer Player = <Player>
				repeat <num_players>
			endif
		elseif StructureContains structure = <data> ($<data_set_id> [<index>])
			switch <data_type>
				case player_info
				switch ($<data_set_id> [<index>])
					case difficulty
					setplayerinfo <player_num> difficulty = (<data>.($<data_set_id> [<index>]).value)
					case part
					setplayerinfo <player_num> part = (<data>.($<data_set_id> [<index>]).value)
					case character_id
					setplayerinfo <player_num> character_id = (<data>.($<data_set_id> [<index>]).value)
					setplayerinfo <player_num> character_savegame = -1
					default
					ScriptAssert 'WARNING need to define new case so that value %c gets stored' c = ($<data_set_id> [<index>])
				endswitch
				case Global
				Change GlobalName = ($<data_set_id> [<index>]) NewValue = (<data> [<index>].value)
				case apearance_data
			endswitch
		endif
		index = (<index> + 1)
		repeat <array_Size>
	endif
endscript

script create_data_sync_container_and_tags 
	RequireParams \{[
			parent_id
			data_set_id
			data_type
		]
		all}
	if ScreenElementExists id = <data_set_id>
		ScriptAssert 'Data sync is still going on for data set %c' c = <data_set_id>
	endif
	CreateScreenElement {
		Type = ContainerElement
		parent = <parent_id>
		id = <data_set_id>
		Pos = (0.0, 0.0)
		tags = {
			player_data = {}
			player_acks = [0 0 0 0 0 0 0 0]
			data_set_id = <data_set_id>
			data_type = <data_type>
		}
	}
endscript

script wait_for_ack_loop 
	printf \{qs(0x3faad9ca)}
	RequireParams \{[
			objID
			wait_time
		]
		all}
	getnumplayersingame
	if (<num_players> > 0)
		count = 0
		begin
		<objID> :GetTags
		getfirstplayer
		num_valid_players = 0
		num_player_acks = 0
		begin
		getplayerinfo <Player> net_obj_id
		if (<net_obj_id> >= 0)
			num_valid_players = (<num_valid_players> + 1)
			if ((<player_acks> [(<Player> - 1)]) = 1)
				num_player_acks = (<player_acks> + 1)
			endif
		endif
		getnextplayer Player = <Player>
		repeat <num_players>
		count = (<count> + 1)
		if (<count> >= (<wait_time> * 2))
			printf \{qs(0x78dbd7ed)}
			break
		endif
		if (<num_valid_players> = <num_player_acks>)
			break
		endif
		Wait \{0.5
			Second}
		repeat <num_players>
	endif
endscript
g_matchmaking_difficulty_difference = 0

script net_matchmaking_ask_accept_lower_difficulty 
	printf \{qs(0x1b35246c)}
	if ScreenElementExists \{id = dialog_box_container}
		printf \{qs(0x6e40243e)}
		return
	endif
	<leader_player> = ($g_leader_player_num)
	if (<leader_player> < 1)
		getfirstplayer \{local}
		<leader_player> = <Player>
	endif
	getplayerinfo <leader_player> difficulty
	if checksumequals a = <difficulty> b = beginner
		printf \{qs(0xbbf82744)}
		return
	endif
	band_lobby_change_focus_submenu_all \{focus_type = unfocus}
	Change \{g_matchmaking_difficulty_difference = 0}
	getplayerinfo <leader_player> controller
	create_dialog_box {
		dlg_z_priority = 1100
		heading_text = qs(0x92fadeaa)
		body_text = qs(0x1cf929c6)
		parent = root_window
		no_background
		options = [
			{
				func = net_matchmaking_ask_return
				text = qs(0xd2915c27)
			}
			{
				func = net_matchmaking_loosen_difficulty
				text = qs(0x58e0a1fb)
			}
		]
		player_device = <controller>
	}
	AssignAlias id = <menu_id> alias = matchmaking_difficulty_loosen_menu
	LaunchEvent \{Type = focus
		target = matchmaking_difficulty_loosen_menu}
	RunScriptOnScreenElement \{id = matchmaking_difficulty_loosen_menu
		net_matchmaking_ask_late_found_players}
endscript

script net_matchmaking_ask_late_found_players 
	printf \{qs(0x30424fac)}
	begin
	if NetSessionFunc \{Obj = match
			func = has_found_players}
		NetSessionFunc \{Obj = match
			func = get_num_matchmaking_players}
		NetSessionFunc \{Obj = party
			func = get_party_members}
		GetArraySize <connections>
		if (<num_matchmaking_players> > <array_Size>)
			net_matchmaking_ask_return
			break
		endif
	endif
	Wait \{1
		gameframe}
	repeat
endscript

script net_matchmaking_ask_return 
	printf \{qs(0x04b3371e)}
	if ScreenElementExists \{id = matchmaking_difficulty_loosen_menu}
		destroy_dialog_box
	endif
	band_lobby_update_button_helpers \{menu = matchmaking}
	band_lobby_change_focus_submenu_all \{focus_type = focus}
endscript

script net_matchmaking_loosen_difficulty 
	printf \{qs(0x705bcaa3)}
	Change \{g_matchmaking_difficulty_difference = 1}
	net_matchmaking_ask_return
endscript

script net_matchmaking_check_accept_difficulty 
	bret = FALSE
	if ScreenElementExists \{id = matchmaking_difficulty_loosen_menu}
	else
		bret = true
	endif
	return <bret> difference = ($g_matchmaking_difficulty_difference)
endscript

script is_accepting_invite_or_sigining_out 
	if (($invite_controller != -1) || ($shutdown_game_for_signin_change_flag = 1))
		return \{true}
	endif
	return \{FALSE}
endscript

script flowsync_sync_blockingforhost 
	flowsync_sync_notblockingforhost
	if IsHost
		begin
		if flowsync_queryreadytocontinue
			break
		endif
		printf \{qs(0x03b05ec3)}
		Wait \{1
			gameframe}
		repeat
	endif
	printf \{qs(0x8044462c)}
endscript

script flowsync_sync_notblockingforhost 
	getnumplayersingame \{local}
	if (<num_players> > 0)
		getfirstplayer \{local}
		begin
		setplayerinfo <Player> sync_point_status = ready_to_continue
		getnextplayer local Player = <Player>
		if (<Player> = -1)
			break
		endif
		repeat
	endif
endscript

script flowsync_queryreadytocontinue 
	if NOT IsHost
		ScriptAssert \{qs(0xe34e779e)}
	endif
	everyone_ready_to_continue = true
	getnumplayersingame
	if (<num_players> > 0)
		getfirstplayer
		begin
		getplayerinfo <Player> sync_point_status
		if (<sync_point_status> = not_ready_to_continue)
			everyone_ready_to_continue = FALSE
			break
		endif
		getnextplayer Player = <Player>
		if (<Player> = -1)
			break
		endif
		repeat
	endif
	return <everyone_ready_to_continue>
endscript

script flowsync_cleanup 
	if NOT IsHost
		ScriptAssert \{qs(0xdc63c03a)}
	endif
	getnumplayersingame
	if (<num_players> > 0)
		getfirstplayer
		begin
		setplayerinfo <Player> sync_point_status = not_ready_to_continue
		getnextplayer Player = <Player>
		if (<Player> = -1)
			break
		endif
		repeat
	endif
endscript

script test_send 
	test1 = 'does this get sent?'
	test2 = DoesThisGetSent
	test3 = DoesThisGetSent2
	printstruct <...>
	SendStructure callback = test_callback data_to_send = <...>
endscript

script test_callback 
	printf \{qs(0xebc04aee)}
	printstruct <...>
endscript

script test_sequenced_msgs 
	SendStructure \{callback = callback_test_sequenced_msgs
		data_to_send = {
			number = 1
		}}
endscript

script callback_test_sequenced_msgs 
	printf qs(0x848da1e2) i = <number>
endscript

script test_retrieve_friends_list 
	NetSessionFunc \{func = friends_init}
	NetSessionFunc \{Obj = friends
		func = begin_retrieve_friends_list
		params = {
			callback = test_friends_callback
			callback_params = {
				None
			}
		}}
endscript

script test_friends_callback 
	printf \{qs(0x1336825d)}
	printstruct <...>
	NetSessionFunc func = createcustommessage params = {deviceNum = 0 userlist = <friendlist> title = qs(0x88482835) game_msg = qs(0x1a7c6769) button_text = qs(0x054c661b) game_specific = guitar}
endscript
general_data_set = [
	difficulty
	part
	character_id
]
global_set = [
	temp_global
]
temp_global = megan_fox

script test_data_sync 
	start_data_sync \{params = {
			data_set_id = general_data_set
			data_type = player_info
		}
		require_ack = 1
		parent_id = root_window}
endscript
